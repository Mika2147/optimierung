        -:    0:Source:raytracer.cc
        -:    0:Graph:raytracer.gcno
        -:    0:Data:raytracer.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// g++ -Wall -pedantic -march=native -mfpmath=sse -mavx2 -O3 raytracer.cc statistics.cc
        -:    2:// Ggf. -std=c++11 hinzufügen
        -:    3:// Für spezifischen FLOAT Wert: -D FLOAT=double oder -D FLOAT='long double' hinzufügen
        -:    4:// Für k-d-Baum Variante:
        -:    5:// g++ -Wall -pedantic -march=native -mfpmath=sse -mavx2  -O3 -D USE_KDTREE raytracer.cc statistics.cc kdtree.cc
        -:    6:// Für optimierten Schnittpunktalgorithmus -D OPTIMIZED_INTERSECTS  hinzufügen
        -:    7:#include <iostream>
        -:    8:#include <memory>
        -:    9:#include <vector>
        -:   10:#include <string>
        -:   11:#include <fstream>
        -:   12:#include <sstream>
        -:   13:#include <limits>
        -:   14:#include <getopt.h> // GNU getopt
        -:   15:#include "math.h"
        -:   16:#include "statistics.h"
        -:   17:#include "triangle.h"
        -:   18:#include "kdtree.h"
        -:   19:
        -:   20:static int resolution_x = 256;
        -:   21:static int resolution_y = 256;
        1:   22:static std::string input_file_name = "examples/teapot.obj";
        1:   23:static std::string output_bmp_file_name = "output.bmp";
        -:   24:static bool reverse_vertice_order = false; // switch to counter clockwise orientation of the input file
        -:   25:static bool write_ppm_to_stdout = true;
        -:   26:
        -:   27:// simple value class for the origin and direction of a ray
        -:   28:template <class T>
        -:   29:class Ray {
        -:   30:private:
        -:   31:  Vector<T, 3> origin;
        -:   32:  Vector<T, 3> direction;
        -:   33:public:
    82903:   34:  Ray(Vector<T, 3> origin, Vector<T, 3> direction) : origin(origin), direction(direction) {
        -:   35:  }
        -:   36:
        -:   37:  Vector<T, 3> getOrigin() const {
519968087:   38:    return origin;
        -:   39:  }
        -:   40:
        -:   41:  Vector<T, 3> getDirection() const {
519968087:   42:    return direction;
        -:   43:  }
        -:   44:
        -:   45:};
        -:   46:
        -:   47:
        -:   48:// a value class for a color in RGB space.
        -:   49:// the red, green, and blue values should be in the range 0.0 to 1.0
        -:   50:// provides methods to add and multiply two colors or a color with a scalar.
        -:   51:class Color {
        -:   52:private:
        -:   53:  FLOAT red, green, blue; // 0.0 - 1.0
        -:   54:public:
        -:   55:  Color(FLOAT red = 0.0, FLOAT green = 0.0, FLOAT blue = 0.0)
    65536:   56:     : red(red), green(green), blue(blue)
        -:   57:  {
        -:   58:  }
        -:   59:
        -:   60:  FLOAT getRed() const {
        -:   61:    return red;
        -:   62:  }
        -:   63:
        -:   64:  FLOAT getGreen() const {
        -:   65:    return green;
        -:   66:  }
        -:   67:
        -:   68:  FLOAT getBlue() const {
        -:   69:    return blue;
        -:   70:  }
        -:   71:
        -:   72:  Color operator+(Color addend) const {
    16389:   73:    return Color(red + addend.red, green + addend.green, blue + addend.blue);
        -:   74:  }
        -:   75:
        -:   76:  Color operator*(Color factor) const {
    16389:   77:    return Color(red * factor.red, green * factor.green, blue * factor.blue);
        -:   78:  }
        -:   79:
        -:   80:  friend Color operator*(const FLOAT factor, Color color)  {
    33756:   81:    return Color(factor * color.red, factor * color.green, factor * color.blue);
        -:   82:  }
        -:   83:};
        -:   84:
        -:   85:
        -:   86:// a value class for material information like the color, ambient and diffuse light factors,
        -:   87:// the amount of reflection and transmission light
        -:   88:class Material {
        -:   89:private:
        -:   90:  Color color;
        -:   91:  FLOAT ambient; //  percent
        -:   92:  FLOAT diffuse; //  percent
        -:   93:  FLOAT reflection; // percent
        -:   94:  FLOAT transmission; // percent
        -:   95:  // sum of all four should be <= 1.0
        -:   96:public:
        -:   97:  Material(Color color = Color(1.0, 0.7, 0.8),
        -:   98:           FLOAT ambient = 0.3,
        -:   99:           FLOAT diffuse = 0.7,
        -:  100:           FLOAT reflection = 0.0,
        -:  101:           FLOAT transmission = 0.0) 
        1:  102:    : color(color), ambient(ambient), diffuse(diffuse), reflection(reflection), transmission(transmission) {
        -:  103:  }
        -:  104:
        -:  105:  Color getColor() const {
    33756:  106:    return color;
        -:  107:  }
        -:  108:
        -:  109:  FLOAT getAmbient() const {
        -:  110:    return ambient;
        -:  111:  }
        -:  112:
        -:  113:  FLOAT getDiffuse() const {
        -:  114:    return diffuse;
        -:  115:  }
        -:  116:
        -:  117:  FLOAT getReflection() const {
        -:  118:    return reflection;
        -:  119:  }
        -:  120:
        -:  121:  FLOAT getTransmission() const {
        -:  122:    return transmission;
        -:  123:  }
        -:  124:};
        -:  125:
        -:  126:
        -:  127:// stores the rasterized screen with the color of each pixel
        1:  128:class Screen {
        -:  129:private:
        -:  130:  size_t width;
        -:  131:  size_t height;
        -:  132:  std::unique_ptr<Color []> buffer;
        -:  133:public:
        1:  134:  Screen(size_t width, size_t  height)
    65537:  135:      : width(width), height(height), buffer(std::unique_ptr<Color []>( new Color[width * height] ))
        -:  136:  {
        1:  137:  }
        -:  138:
        -:  139:  void setPixel(size_t x, size_t y, Color color) {
   262144:  140:    buffer[x + y * width] = color;
        -:  141:  }
        -:  142:
        -:  143:  void clear(Color color = Color(0.0, 0.0, 0.0) ) {
      513:  144:    for (size_t x = 0u; x < getWidth(); x++) {
   131328:  145:      for (size_t y = 0u; y < getHeight(); y++) {
        -:  146:         setPixel(x, y, color );
        -:  147:      }
        -:  148:    }
        -:  149:  }
        -:  150:
        -:  151:  size_t getWidth() const {
        -:  152:    return this->width;
        -:  153:  }
        -:  154:  size_t getHeight() const {
        -:  155:    return this->height;
        -:  156:  }
        -:  157:
        -:  158:  Color getPixel(size_t x, size_t y) const {
   786432:  159:    return buffer[x + y * width];
        -:  160:  }
        -:  161:
        -:  162:};
        -:  163:
        -:  164:// a simple camera that can be used for a central projection from an eye to a rectangular view port
        -:  165:// defined by a upper left point and a vector pointing downsides and to the right
        -:  166:// both vectors should be located in the same plane and orthogonal to  the eye->center ray (projection is distorted otherwise)
        -:  167:// the viewport has a defined pixel height and width 
        -:  168:class Camera {
        -:  169:  Vector<FLOAT, 3> eye,
        -:  170:               upper_left,
        -:  171:               down,
        -:  172:               right;
        -:  173:  FLOAT pixelWidth;
        -:  174:  FLOAT pixelHeight;
        -:  175:public:
        -:  176:
        1:  177:  Camera(Vector<FLOAT, 3> eye, Vector<FLOAT, 3> center, Vector<FLOAT, 3>up, Vector<FLOAT, 3> right, FLOAT pixelWidth = 1.0, FLOAT pixelHeight = 1.0 )
        5:  178:    : eye(eye), upper_left(center - right + up), down(-2.0 * up), right(2.0 * right), pixelWidth(pixelWidth), pixelHeight(pixelHeight) {
        1:  179:     this->right.normalize();
        1:  180:     this->down.normalize();
        1:  181:  }
        -:  182:
        -:  183:  // creates a camera from a given eye->center ray
        -:  184:  // this ray points to a center of a rectangle created by an up and right vector
        -:  185:  // the pixel height and width are calculated from the screen coordiates with the length of the up and right vector
        1:  186:  Camera(Vector<FLOAT, 3> eye, Vector<FLOAT, 3> center, Vector<FLOAT, 3> up, Vector<FLOAT, 3> right, Screen & screen )
        1:  187:    : Camera(eye, center, up, right,
        1:  188:             2.0 * ( right.length() / screen.getWidth() ),
        2:  189:             2.0 * ( up.length() / screen.getHeight() ) ) {
        1:  190:  }
        -:  191:
        -:  192:  // returns a ray pointing to the given x,y from this camera's eye point
    65536:  193:  Ray<FLOAT> getRay(size_t x, size_t y) const {
        -:  194:    Vector<FLOAT, 3> direction = (upper_left
   196608:  195:                  + (x * pixelWidth) * right
   196608:  196:                  + (y * pixelHeight) * down )
        -:  197:                  - eye;
    65536:  198:    return Ray<FLOAT>(eye, direction);
        -:  199:  }
        -:  200:};
        -:  201:
        -:  202:
        -:  203:// puts out the image as PPM
        1:  204:std::ostream & operator<<(std::ostream & out, const Screen & screen) {
        -:  205:  out << "P3" << std::endl;
        2:  206:  out << screen.getWidth() << " " << screen.getHeight() << std::endl;
        -:  207:  out << "255" << std::endl;
      513:  208:  for (size_t y = 0u; y < screen.getHeight(); y++) {
   131328:  209:    for (size_t x = 0u; x < screen.getWidth(); x++) {
    65536:  210:      std::cout << (unsigned short) (screen.getPixel(x,y).getRed() * 255.0) << " "
    65536:  211:                << (unsigned short) (screen.getPixel(x,y).getGreen() * 255.0) << " "
   131072:  212:                << (unsigned short) (screen.getPixel(x,y).getBlue() * 255.0) << " ";
        -:  213:    }
        -:  214:    std::cout << std::endl;
        -:  215:  }
        -:  216:  std::cout << std::endl;
        1:  217:  return out;
        -:  218:}
        -:  219:
        -:  220:// writes out the image as binary BMP (for windows)
        1:  221:void write_bmp(std::ostream & out, const Screen & screen) {
        1:  222:  unsigned long long size_of_bitmap_data = screen.getWidth() * screen.getHeight() * 4;
        1:  223:  out.put(0x42); out.put(0x4D); // "BM"
        1:  224:  out.put(0x00); out.put(0x00); out.put(0x00); out.put(0x00); // size of bmp file
        1:  225:  out.put(0x00); out.put(0x00);
        1:  226:  out.put(0x00); out.put(0x00);
        1:  227:  out.put(0x36); out.put(0x00);out.put(0x00); out.put(0x00); // offset to start of pixel array
        -:  228:  // Header
        1:  229:  out.put(0x28); out.put(0x00); out.put(0x00); out.put(0x00);  // 40 bytes Number of bytes in the DIB header (from this point)
        1:  230:  out.put( screen.getWidth() & 0xFF ); out.put( screen.getWidth() >> 8 & 0xFF );
        1:  231:  out.put(0x00); out.put(0x00); // width in pixel
        1:  232:  out.put( screen.getHeight() & 0xFF ); out.put( screen.getHeight() >> 8 & 0xFF );
        1:  233:  out.put(0x00); out.put(0x00); // height in pixel
        1:  234:  out.put(0x01); out.put(0x00); // 1 = number of color planes used
        1:  235:  out.put(0x18); out.put(0x00); // 24 bits per pixel (RGB)
        1:  236:  out.put(0x00); out.put(0x00); out.put(0x00); out.put(0x00); // 0 = no compression
        -:  237:  // size of raw bitmap data 16 bytes
        1:  238:  out.put(size_of_bitmap_data & 0xFF); 
        1:  239:  out.put(size_of_bitmap_data >> 8 & 0xFF); 
        1:  240:  out.put(size_of_bitmap_data >> 16 & 0xFF); 
        1:  241:  out.put(size_of_bitmap_data >> 32 & 0xFF); 
        1:  242:  out.put(0x13); out.put(0x0B); out.put(0x00); out.put(0x00); // 72 DPI resolution for printing
        1:  243:  out.put(0x13); out.put(0x0B); out.put(0x00); out.put(0x00); //           "
        1:  244:  out.put(0x00); out.put(0x00); out.put(0x00); out.put(0x00); // 0 colors in the palette
        1:  245:  out.put(0x00); out.put(0x00); out.put(0x00); out.put(0x00); // 0 = all colors are important
        -:  246:  // start of pixel map array, 4 byte alignment padding at end of line if nedded
      513:  247:  for (size_t y = 0u; y < screen.getHeight(); y++ ) {
   131328:  248:    for (size_t x = 0u; x < screen.getWidth(); x++) {
   131072:  249:      out.put( ((unsigned short) (screen.getPixel(x, screen.getHeight() - 1 - y).getRed() * 255.0) ) & 0xFF );
   131072:  250:      out.put( ((unsigned short) (screen.getPixel(x, screen.getHeight() - 1 - y).getGreen() * 255.0) ) & 0xFF );
   131072:  251:      out.put( ((unsigned short) (screen.getPixel(x, screen.getHeight() - 1 - y).getBlue() * 255.0) ) & 0xFF );
        -:  252:    }
      256:  253:    for (size_t padding_bytes = 0u; padding_bytes < screen.getWidth() % 4; padding_bytes++) {
    #####:  254:      out.put( 0x00 );
        -:  255:    }
        -:  256:  } 
        1:  257:}
        -:  258:
        -:  259:// a simple light source with a position and a light color
        -:  260:// the light is emitted evenly from the given position in all directions
        -:  261:class Light {
        -:  262:  Vector<FLOAT, 3> position;
        -:  263:  Color color;
        -:  264:public:
        -:  265:  Light(Vector<FLOAT, 3> position = Vector<FLOAT, 3>({0.0, 0.0, 1000.0}),
        -:  266:        Color color = Color(1.0, 1.0, 1.0) )
        -:  267:    : position(position), color(color) {
        -:  268:  }
        -:  269:
        -:  270:  Color getColor() const {
        -:  271:     return color;
        -:  272:  }
        -:  273:
        -:  274:  Vector<FLOAT, 3> getPosition() const {
        -:  275:    return position;
        -:  276:  }
        -:  277:};
        -:  278:
        -:  279:// the scene with all triangles and light sources
        -:  280:// contains the algorithm to determine the visible triangle for a given ray
        2:  281:class Scene {
        -:  282:  std::vector< Triangle<FLOAT> > triangles;
        -:  283:  std::vector< Light > lights;
        -:  284:public:
        -:  285:  void add(Triangle<FLOAT> triangle) {
     6320:  286:    triangles.push_back( triangle );
        -:  287:  }
        -:  288:
        -:  289:  void addLight(Light light) {
        1:  290:    lights.push_back( light );
        -:  291:  }
        -:  292:
        -:  293:  //  quickfix, do not alter triangles after calling this method
        1:  294:  std::vector< Triangle<FLOAT> * > getTriangles() {
        -:  295:    std::vector< Triangle<FLOAT> * > triangles_ptr;
    18962:  296:    for (size_t i = 0; i < triangles.size(); i++) {
    12640:  297:      triangles_ptr.push_back( &triangles[i] );      
        -:  298:    }    
        1:  299:    return triangles_ptr;
        -:  300:  }
        -:  301:
        -:  302:  // brute force algorithme to determine the nearest (if NEAREST is true) triangle of this scence that has
        -:  303:  // an intersection with the given ray
        -:  304:  // the intersection point p is p = ray.origin + t * ray.direction
        -:  305:  // the u-v parameters are the barycentric coordinates of the intersection within  the triangle
        -:  306:
    82903:  307:bool hasNearestTriangle(const Ray<FLOAT> & ray, Triangle<FLOAT> *  & nearest_triangle, FLOAT &t, FLOAT &u, FLOAT &v, const bool NEAREST = true)  {
        -:  308:  FLOAT minimum_t = INFINITY;
        -:  309:  FLOAT minimum_u  = 0.0, minimum_v = 0.0;
1560015032:  310:  for (size_t i = 0u; i < triangles.size(); i++) {
        -:  311:    Triangle<FLOAT> *triangle = &triangles[i];
519950720:  312:    stats.no_ray_triangle_intersection_tests++;
519950720:  313:    bool intersect = triangle->intersects(ray.getOrigin(), ray.getDirection(), t, u, v, minimum_t);
519950720:  314:    if ( intersect ) {
    38215:  315:      stats.no_ray_triangle_intersections_found++;          
    38215:  316:      if ( (nearest_triangle == nullptr)  || (t < minimum_t) ) {      
    35290:  317:        minimum_t = t;
    35290:  318:        minimum_u = u;
    35290:  319:        minimum_v = v;
    35290:  320:        nearest_triangle = triangle;
    35290:  321:        if ( ! NEAREST ) {
        -:  322:          return true;
        -:  323:        }
        -:  324:      }
        -:  325:    }
        -:  326:  }
    81925:  327:  t = minimum_t;
    81925:  328:  u = minimum_u;
    81925:  329:  v = minimum_v;
    81925:  330:  return nearest_triangle != nullptr;
        -:  331:}
        -:  332:
        -:  333:
        -:  334:
        -:  335:  // return true iff the ray is blocked by a triangle
        -:  336:  bool blocked(const Ray<FLOAT> & ray)  {
    17367:  337:     Triangle<FLOAT> * triangle = nullptr;
        -:  338:     FLOAT t,u,v;
    17367:  339:     return hasNearestTriangle(ray, triangle, t, u, v, false);
        -:  340:  }
        -:  341:
        -:  342:  // shades the intersection point of the ray with the triangle with the material information
        -:  343:  // the normal vectors and u-v-parameter are used for interpolation
    17367:  344:  Color shade(const Ray<FLOAT> & ray, Triangle<FLOAT> & triangle, Material & material, FLOAT &t, FLOAT &u, FLOAT &v)  {
    17367:  345:    Color color =  material.getAmbient() * material.getColor();
    34734:  346:    FLOAT factor = 1.0 / lights.size();
    52101:  347:    Vector<FLOAT, 3> intersection = (ray.getOrigin() + 0.9999 * t * ray.getDirection());
    69468:  348:    Vector<FLOAT, 3> normal = (u * triangle.n1) + (v * triangle.n2) + ( (1.0 - u - v) * triangle.n3);    
        -:  349:    
    17367:  350:    normal.normalize();
    34734:  351:    for (Light light : lights) {
    34734:  352:      Vector<FLOAT, 3> light_direction = light.getPosition() - intersection;
        -:  353:      const Ray<FLOAT> ray_to_light(intersection, light_direction);
    17367:  354:      if ( ! blocked( ray_to_light )  ) { 
    16389:  355:        light_direction.normalize();
    32778:  356:        FLOAT angle = std::max<FLOAT>(0.0, light_direction.scalar_product(normal));
    16389:  357:        color = color + angle * factor * material.getDiffuse() * material.getColor() * light.getColor();
        -:  358:      }
        -:  359:    }
    17367:  360:    return color;
        -:  361:  }
        -:  362:};
        -:  363:
        -:  364:// Reads in 3d scene from Wavefront.obj
        -:  365:// only triangles are read in, no polygones, no normals
        -:  366:// only lines starting with v (vertexes) and f (faces) are read in
        -:  367:// other lines are ignored
        1:  368:void read_wavefront(std::ifstream & in, Scene & scene) {
        -:  369:  std::vector< Vector<FLOAT, 3> > vertices;
        -:  370:  std::vector< Vector<FLOAT, 3> > normals;
        -:  371:  size_t no_of_triangles = 0u;
        -:  372:  Vector<FLOAT, 3> vertice;
        -:  373:  Vector<FLOAT, 3> normal;
        -:  374:  char c;
    27230:  375:  while (in >> c) {
    13614:  376:    if (c == 'v' && in.peek() == ' ') {
        -:  377:       FLOAT x, y, z;
        -:  378:       in >> x;
        -:  379:       in >> y;
        -:  380:       in >> z;
     7288:  381:       vertice = Vector<FLOAT, 3>( {x, y, z} );
     3644:  382:       vertices.push_back( vertice ); 
    16290:  383:    } else if (c == 'f' && in.peek() == ' ') {
        -:  384:
        -:  385:       size_t xv, yv, zv;
     6320:  386:       size_t xn = 0, yn, zn;
        -:  387:       in >> xv;
     6320:  388:       if (in.peek() == '/') in.ignore(); // no texture coordinates supported
     6320:  389:       if (in.peek() == '/') { in.ignore(); in >> xn;}
        -:  390:       in >> yv;
     6320:  391:       if (in.peek() == '/') in.ignore(); // no texture coordinates supported
     6320:  392:       if (in.peek() == '/') { in.ignore(); in >> yn;}
        -:  393:       in >> zv;
     6320:  394:       if (in.peek() == '/') in.ignore(); // no texture coordinates supported
     6320:  395:       if (in.peek() == '/') { in.ignore(); in >> zn;}
        -:  396:       
     6320:  397:       if (reverse_vertice_order) {
        -:  398:         std::swap(yv, zv);
        -:  399:         std::swap(yn, zn);
        -:  400:       }
     6320:  401:       if (xn == 0) { // no normals 
    #####:  402:         scene.add(Triangle<FLOAT> ( {vertices[xv - 1], vertices[yv - 1], vertices[zv - 1]} ));
        -:  403:       } else {
    50560:  404:         scene.add(Triangle<FLOAT> ( {vertices[xv - 1], vertices[yv - 1], vertices[zv - 1], normals[xn - 1], normals[yn - 1], normals[zn - 1]} ));
        -:  405:       }
     6320:  406:       no_of_triangles++;
     7294:  407:    } else if (c == 'v' && in.peek() == 'n') {
     3644:  408:       in >> c;
     3644:  409:       if ( in.peek() == ' ' ) {
        -:  410:         FLOAT nx, ny, nz;
        -:  411:         in >> nx;
        -:  412:         in >> ny;
        -:  413:         in >> nz;
     7288:  414:         normal = Vector<FLOAT, 3>( {nx, ny, nz} );
     3644:  415:         normals.push_back( normal );         
        -:  416:       }
        -:  417:    }
        -:  418:    // read to end of line
    13614:  419:    in.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        -:  420:  }
        -:  421:
        -:  422:  std::cerr << "no of triangles : " << no_of_triangles << std::endl;
        1:  423:  std::cerr << "no of vertices : " << vertices.size() << std::endl;
        1:  424:  std::cerr << "no of normals : " << normals.size() << std::endl;
        1:  425:  std::cerr << "memory used for all triangles [byte] : " << no_of_triangles * sizeof(Triangle<FLOAT>) << std::endl;   
        1:  426:}
        -:  427:
        -:  428:
        -:  429:// the raytrace algorithm but without refraction and reflection
        1:  430:void raytrace(Camera &camera, Scene & scene, Screen & screen, KDTree *tree = nullptr) {
        -:  431:  screen.clear();
        -:  432:  Material material;
        -:  433:  Color color;
      513:  434:  for (FLOAT x = 0.0; x < screen.getWidth(); x++) {
   131328:  435:    for (FLOAT y = 0.0; y < screen.getHeight(); y++) {
        -:  436:      color = Color(0.0, 0.0, 0.0);
    65536:  437:      const Ray<FLOAT> ray = camera.getRay(x,y);
    65536:  438:      Triangle<FLOAT> *nearest_triangle = nullptr;
    65536:  439:      FLOAT t = INFINITY, u = 0, v = 0;
        -:  440:#ifndef USE_KDTREE
    65536:  441:      bool hasNearestTriangle = scene.hasNearestTriangle(ray, nearest_triangle, t, u, v);
        -:  442:#else
        -:  443:      bool hasNearestTriangle = tree->hasNearestTriangle(ray.getOrigin(), ray.getDirection(),  nearest_triangle, t, u, v);
        -:  444:#endif
    65536:  445:      if ( hasNearestTriangle ) {
        -:  446:        // no reflection and refraction
    17367:  447:        color = scene.shade(ray, *nearest_triangle, material, t, u, v);
        -:  448:      }
        -:  449:      screen.setPixel(x, y, color);
        -:  450:    }
        -:  451:  }
        1:  452:}
        -:  453:
        -:  454:
        -:  455:
        -:  456:
        1:  457:void parse_arguments(int argc, char *argv[]) {
        -:  458:  static struct option long_options[] = {
        -:  459:   {"file", required_argument, 0, 'f'},
        -:  460:   {"width", required_argument, 0, 'w'},
        -:  461:   {"height", required_argument, 0, 'h'},
        -:  462:   {"help", optional_argument, 0, 'u'},
        -:  463:   {"no_ppm", optional_argument, 0, 'n'},
        -:  464:  };
        -:  465:  int c;
        -:  466:  int option_index;
        -:  467:
        1:  468:  while ( (c = getopt_long (argc, argv, "ro:", long_options, &option_index)) != -1 ) {
    #####:  469:    switch (c) {
    #####:  470:    case 'f': input_file_name = std::string(optarg);
    #####:  471:              break;
    #####:  472:    case 'r': reverse_vertice_order = true;
    #####:  473:              break;
    #####:  474:    case 'w': resolution_x = std::stoi(optarg);
    #####:  475:              break;
    #####:  476:    case 'h': resolution_y = std::stoi(optarg);
    #####:  477:              break;
    #####:  478:    case 'o': output_bmp_file_name = std::string(optarg);
    #####:  479:              break;
    #####:  480:    case 'n': write_ppm_to_stdout = false;
    #####:  481:              break;
    #####:  482:    case 'u': std::cout << "Aufruf: " << argv[0] << " [options]" << std::endl;
        -:  483:              std::cout << "  --file FILE          wavefront obj input file ('example/teapot.obj')" << std::endl;
        -:  484:              std::cout << "  --width WIDTH        horizontal resolution (256)" << std::endl;
        -:  485:              std::cout << "  --height HEIGHT      vertical resolution (256)" << std::endl;
        -:  486:              std::cout << "  --help               this help text" << std::endl;
        -:  487:              std::cout << "  --no_ppm             no PPM output is generated" << std::endl;
        -:  488:              std::cout << "  -o BMP               BMP output file ('output.bmp')" << std::endl;
        -:  489:              std::cout << "  -r                   reverse vertice order of triangles in input file" << std::endl;
    #####:  490:              exit(0);
        -:  491:    } 
        -:  492:  }
        -:  493:
        -:  494:  std::cerr << "reading from       : " << input_file_name << std::endl;
        -:  495:  std::cerr << "writing bmp to     : " << output_bmp_file_name << std::endl;
        1:  496:  std::cerr << "resolution x set to: " << resolution_x << std::endl;
        1:  497:  std::cerr << "resolution y set to: " << resolution_y << std::endl;
        1:  498:  std::cerr << "vertices reversed  : " << reverse_vertice_order << std::endl;
        1:  499:  std::cerr << "write ppm          : " << write_ppm_to_stdout << std::endl;
        1:  500:}
        -:  501:
        1:  502:int main(int argc, char *argv[]) {
        1:  503:  parse_arguments(argc, argv);
        1:  504:  Scene scene;
        1:  505:  scene.addLight( Light( Vector<FLOAT,3>{500.0, 500.0, 1000.0}) );
        2:  506:  std::ifstream input(input_file_name);
        2:  507:  std::ofstream output(output_bmp_file_name, std::ofstream::binary); // for windows
        1:  508:  read_wavefront(input, scene);
        1:  509:  std::vector<Triangle<FLOAT> *> triangles = scene.getTriangles();
        1:  510:  Screen screen(resolution_x, resolution_y);
        -:  511:
        -:  512:
        -:  513:  // camera for teapot_large.obj
        -:  514:  Camera camera( Vector<FLOAT, 3>( {  0.05, 1.0, 200.0} ),
        -:  515:                 Vector<FLOAT, 3>( {  0.05, 1.0, 100.0} ),
        -:  516:                 Vector<FLOAT, 3>( {  0.0, 1.6, 0.0} ),
        -:  517:                 Vector<FLOAT, 3>( {  1.6, 0.0,  0.0} ),
        1:  518:                 screen );
        -:  519:
        1:  520:  stats.time_start();
        -:  521:#ifndef USE_KDTREE
        1:  522:  raytrace(camera, scene, screen);
        -:  523:#else
        -:  524:  std::unique_ptr<KDTree> tree =  std::unique_ptr<KDTree>( KDTree::buildTree( triangles ) );
        -:  525:  raytrace(camera, scene, screen, tree.get());
        -:  526:#endif
        1:  527:  stats.time_stop();
        1:  528:  if (write_ppm_to_stdout) {
        1:  529:    std::cout << screen; // write image in PPM format to the standard output
        -:  530:  }
        1:  531:  write_bmp(output, screen);
        1:  532:  output.close();
        1:  533:  stats.print();
        -:  534:
        -:  535:  return 0;
        3:  536:}
        -:  537:
